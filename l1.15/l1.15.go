package main

// Рассмотреть следующий код и ответить на вопросы:
// 		к каким негативным последствиям он может привести
// 		и как это исправить?
// Приведите корректный пример реализации.

// var justString string

// func someFunc() {
//   v := createHugeString(1 &lt;&lt; 10)
//   justString = v[:100]
// }

// func main() {
//   someFunc()
// }
// Вопрос: что происходит с переменной justString?

import "errors"

var justString string

func someFunc() error {
	v := createHugeString(1 << 10)

	if len(v) < 100 {
		return errors.New("Создана слишком короткая строка")
	}

	justString = string([]byte(v[:100]))
	return nil
}

func main() {
	someFunc()
}

// При первоначальной реализации justString будет ссылаться на первые 100 символов Большой строки,
// при этом сама Большая строка (1024 символа) будет храниться в памяти,
// так как Go использует общий массив данных
//
// Если createHugeString вернет строку, в которой будет меньше 100 символов,
// Go вызовет панику при попытке создать срез превышающий длину созданной строки
//
// В случае с `string([]byte(v[:100]))`, v[:100] – указывает на Большую строку,
// byte(v[:100]) копирует данные в новый байтовый массив
// string([]byte(v[:100])) преобразует новый байтовый массив в строку,
// таким образом justString ссылается на новую строку из 100 символов, а не на 100 символов из Большой строки
//
// В последствии, сборшик мусора освободит память, которая была выделена для Большой строки,
// так как на нее больше не ссылаются
